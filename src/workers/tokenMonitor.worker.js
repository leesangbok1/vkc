/**
 * Background Token Monitor Worker
 * Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú ÌÜ†ÌÅ∞ ÏÉÅÌÉúÎ•º Î™®ÎãàÌÑ∞ÎßÅÌïòÍ≥† ÏûêÎèô Ïû¨Í∞ú Ï≤òÎ¶¨
 */

// Worker Ï†ÑÏó≠ ÏÉÅÌÉú
let isMonitoring = false
let monitoringInterval = null
let services = new Map()
let taskQueue = []
let config = {
  checkInterval: 30000, // 30Ï¥à
  apiTimeout: 10000,   // 10Ï¥à
  maxRetries: 3
}

// Î©îÏãúÏßÄ Ìï∏Îì§Îü¨
self.onmessage = async function(e) {
  const { type, data } = e.data

  try {
    switch (type) {
      case 'INIT':
        await initialize(data)
        break
      case 'START_MONITORING':
        startMonitoring()
        break
      case 'STOP_MONITORING':
        stopMonitoring()
        break
      case 'UPDATE_CONFIG':
        updateConfig(data)
        break
      case 'CHECK_SERVICES':
        await checkAllServices()
        break
      case 'UPDATE_SERVICES':
        updateServices(data)
        break
      case 'UPDATE_QUEUE':
        updateQueue(data)
        break
      case 'GET_STATUS':
        sendStatus()
        break
      default:
        throw new Error(`Unknown message type: ${type}`)
    }
  } catch (error) {
    self.postMessage({
      type: 'ERROR',
      error: error.message,
      timestamp: Date.now()
    })
  }
}

/**
 * Worker Ï¥àÍ∏∞Ìôî
 */
async function initialize(initData) {
  config = { ...config, ...initData.config }
  services = new Map(Object.entries(initData.services || {}))
  taskQueue = initData.taskQueue || []

  self.postMessage({
    type: 'INITIALIZED',
    timestamp: Date.now()
  })

  console.log('ü§ñ Token Monitor Worker Ï¥àÍ∏∞ÌôîÎê®')
}

/**
 * Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
 */
function startMonitoring() {
  if (isMonitoring) return

  isMonitoring = true

  monitoringInterval = setInterval(async () => {
    await checkAllServices()
    await processTokenRecovery()
  }, config.checkInterval)

  self.postMessage({
    type: 'MONITORING_STARTED',
    timestamp: Date.now()
  })

  console.log('üìä Î∞±Í∑∏ÎùºÏö¥Îìú ÌÜ†ÌÅ∞ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë')
}

/**
 * Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ
 */
function stopMonitoring() {
  isMonitoring = false

  if (monitoringInterval) {
    clearInterval(monitoringInterval)
    monitoringInterval = null
  }

  self.postMessage({
    type: 'MONITORING_STOPPED',
    timestamp: Date.now()
  })

  console.log('üõë Î∞±Í∑∏ÎùºÏö¥Îìú ÌÜ†ÌÅ∞ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ')
}

/**
 * ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏
 */
function updateConfig(newConfig) {
  config = { ...config, ...newConfig }

  // Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏù¥Î©¥ Ïû¨ÏãúÏûë
  if (isMonitoring) {
    stopMonitoring()
    startMonitoring()
  }

  self.postMessage({
    type: 'CONFIG_UPDATED',
    config,
    timestamp: Date.now()
  })
}

/**
 * ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
 */
function updateServices(servicesData) {
  services = new Map(Object.entries(servicesData))

  self.postMessage({
    type: 'SERVICES_UPDATED',
    timestamp: Date.now()
  })
}

/**
 * ÏûëÏóÖ ÌÅê ÏóÖÎç∞Ïù¥Ìä∏
 */
function updateQueue(queueData) {
  taskQueue = queueData

  self.postMessage({
    type: 'QUEUE_UPDATED',
    queueLength: taskQueue.length,
    timestamp: Date.now()
  })
}

/**
 * Î™®Îì† ÏÑúÎπÑÏä§ ÏÉÅÌÉú ÌôïÏù∏
 */
async function checkAllServices() {
  const results = {}

  for (const [serviceId, service] of services) {
    try {
      const status = await checkServiceStatus(serviceId, service)
      results[serviceId] = status

      // ÏÑúÎπÑÏä§ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      service.status = status.available ? 'available' : 'limited'
      service.lastCheck = Date.now()
      if (status.rateLimitInfo) {
        service.rateLimitInfo = status.rateLimitInfo
      }
      if (status.resetTime) {
        service.resetTime = status.resetTime
      }
    } catch (error) {
      results[serviceId] = {
        available: false,
        error: error.message
      }
      service.status = 'error'
      service.lastCheck = Date.now()
      service.error = error.message
    }
  }

  self.postMessage({
    type: 'SERVICE_STATUS_UPDATE',
    results,
    timestamp: Date.now()
  })
}

/**
 * ÌäπÏ†ï ÏÑúÎπÑÏä§ ÏÉÅÌÉú ÌôïÏù∏
 */
async function checkServiceStatus(serviceId, service) {
  switch (serviceId) {
    case 'claude':
      return await checkClaudeStatus(service)
    case 'github':
      return await checkGitHubStatus(service)
    case 'firebase':
      return await checkFirebaseStatus(service)
    default:
      throw new Error(`Unknown service: ${serviceId}`)
  }
}

/**
 * Claude API ÏÉÅÌÉú ÌôïÏù∏
 */
async function checkClaudeStatus(service) {
  if (!service.apiKey) {
    throw new Error('Claude API key not configured')
  }

  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), config.apiTimeout)

  try {
    const response = await fetch(`${service.baseUrl}/messages`, {
      method: 'POST',
      headers: {
        'x-api-key': service.apiKey,
        'Content-Type': 'application/json',
        'anthropic-version': '2023-06-01'
      },
      body: JSON.stringify({
        model: 'claude-3-haiku-20240307',
        max_tokens: 1,
        messages: [{ role: 'user', content: 'test' }]
      }),
      signal: controller.signal
    })

    clearTimeout(timeoutId)

    const rateLimitInfo = {
      requestsLimit: response.headers.get('anthropic-ratelimit-requests-limit'),
      requestsRemaining: response.headers.get('anthropic-ratelimit-requests-remaining'),
      requestsReset: response.headers.get('anthropic-ratelimit-requests-reset'),
      tokensLimit: response.headers.get('anthropic-ratelimit-tokens-limit'),
      tokensRemaining: response.headers.get('anthropic-ratelimit-tokens-remaining'),
      tokensReset: response.headers.get('anthropic-ratelimit-tokens-reset')
    }

    let resetTime = null
    if (response.status === 429) {
      const retryAfter = response.headers.get('retry-after')
      resetTime = retryAfter ? Date.now() + (parseInt(retryAfter) * 1000) : null
    }

    return {
      available: response.status !== 429,
      rateLimitInfo,
      resetTime,
      statusCode: response.status
    }
  } catch (error) {
    clearTimeout(timeoutId)
    if (error.name === 'AbortError') {
      throw new Error('Request timeout')
    }
    throw error
  }
}

/**
 * GitHub API ÏÉÅÌÉú ÌôïÏù∏
 */
async function checkGitHubStatus(service) {
  if (!service.apiKey) {
    throw new Error('GitHub API key not configured')
  }

  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), config.apiTimeout)

  try {
    const response = await fetch(`${service.baseUrl}/rate_limit`, {
      headers: {
        'Authorization': `token ${service.apiKey}`,
        'Accept': 'application/vnd.github.v3+json'
      },
      signal: controller.signal
    })

    clearTimeout(timeoutId)

    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.statusText}`)
    }

    const data = await response.json()
    const core = data.rate || data.resources?.core || {}

    return {
      available: core.remaining > 100,
      rateLimitInfo: {
        limit: core.limit,
        remaining: core.remaining,
        used: core.used,
        reset: core.reset
      },
      resetTime: core.reset ? core.reset * 1000 : null
    }
  } catch (error) {
    clearTimeout(timeoutId)
    if (error.name === 'AbortError') {
      throw new Error('Request timeout')
    }
    throw error
  }
}

/**
 * Firebase ÏÉÅÌÉú ÌôïÏù∏ (WorkerÏóêÏÑúÎäî Í∞ÑÎã®Ìïú Ìïë Ï≤¥ÌÅ¨)
 */
async function checkFirebaseStatus(service) {
  // WorkerÏóêÏÑúÎäî Firebase SDKÎ•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏúºÎØÄÎ°ú
  // Î©îÏù∏ Ïä§Î†àÎìúÏóê ÌôïÏù∏ ÏöîÏ≤≠
  return new Promise((resolve) => {
    const messageId = Date.now()

    const handleResponse = (e) => {
      if (e.data.type === 'FIREBASE_STATUS_RESPONSE' && e.data.messageId === messageId) {
        self.removeEventListener('message', handleResponse)
        resolve(e.data.result)
      }
    }

    self.addEventListener('message', handleResponse)

    self.postMessage({
      type: 'REQUEST_FIREBASE_STATUS',
      messageId,
      timestamp: Date.now()
    })

    // 5Ï¥à ÌõÑ ÌÉÄÏûÑÏïÑÏõÉ
    setTimeout(() => {
      self.removeEventListener('message', handleResponse)
      resolve({
        available: false,
        error: 'Firebase status check timeout'
      })
    }, 5000)
  })
}

/**
 * ÌÜ†ÌÅ∞ Î≥µÍµ¨ Ï≤òÎ¶¨
 */
async function processTokenRecovery() {
  const availableServices = []
  const limitedServices = []

  for (const [serviceId, service] of services) {
    if (service.status === 'available') {
      availableServices.push(serviceId)
    } else if (service.status === 'limited' && service.resetTime && Date.now() >= service.resetTime) {
      // Î¶¨ÏÖã ÏãúÍ∞ÑÏù¥ ÏßÄÎÇ¨ÏúºÎ©¥ Îã§Ïãú ÌôïÏù∏
      await checkServiceStatus(serviceId, service)
      if (service.status === 'available') {
        availableServices.push(serviceId)
      }
    } else if (service.status === 'limited') {
      limitedServices.push(serviceId)
    }
  }

  // Î≥µÍµ¨Îêú ÏÑúÎπÑÏä§Í∞Ä ÏûàÍ≥† ÎåÄÍ∏∞ Ï§ëÏù∏ ÏûëÏóÖÏù¥ ÏûàÏúºÎ©¥ ÏïåÎ¶º
  if (availableServices.length > 0 && taskQueue.length > 0) {
    self.postMessage({
      type: 'TOKEN_RECOVERY_DETECTED',
      availableServices,
      queueLength: taskQueue.length,
      timestamp: Date.now()
    })
  }

  // Ï†úÌïúÎêú ÏÑúÎπÑÏä§ Ï†ïÎ≥¥ Ï†ÑÏÜ°
  if (limitedServices.length > 0) {
    const limitedInfo = limitedServices.map(serviceId => {
      const service = services.get(serviceId)
      return {
        serviceId,
        serviceName: service.name,
        resetTime: service.resetTime,
        timeUntilReset: service.resetTime ? service.resetTime - Date.now() : null
      }
    })

    self.postMessage({
      type: 'SERVICES_LIMITED',
      services: limitedInfo,
      timestamp: Date.now()
    })
  }
}

/**
 * ÌòÑÏû¨ ÏÉÅÌÉú Ï†ÑÏÜ°
 */
function sendStatus() {
  self.postMessage({
    type: 'STATUS_RESPONSE',
    status: {
      isMonitoring,
      services: Object.fromEntries(services),
      queueLength: taskQueue.length,
      config
    },
    timestamp: Date.now()
  })
}

// Worker Ï¢ÖÎ£å Ïãú Ï†ïÎ¶¨
self.addEventListener('beforeunload', () => {
  stopMonitoring()
})

console.log('üîß Token Monitor Worker Î°úÎìúÎê®')